name: "PowerShell Module Cache"
branding:
  icon: "download"
  color: "gray-dark"
description: "Cache modules from the PowerShell Gallery"
inputs:
  modules-to-cache:
    description: "The PowerShell modules to cache from the PowerShell Gallery"
    required: false
  shell-to-use:
    description: "The default shell to use. Defaults to pwsh. Options are pwsh or powershell."
    required: false
    default: "pwsh"
  modules-to-cache-final:
    description: "Auto-generated module list"
    required: false
  skip-publisher-check:
    description: "Skip publisher check during Install-Module"
    required: false
    default: "true"
  allow-prerelease:
    description: "Allow prerelease during Install-Module"
    required: false
    default: "true"
  force:
    description: "Force during Install-Module"
    required: false
    default: "true"
runs:
  using: "composite"
  steps:
    - id: psoutput
      shell: pwsh
      run: |
        if ("${{ inputs.modules-to-cache }}") {
          Write-Output "Getting variables for cacher"
          $keygen = ${{ github.action_path }}/main.ps1 -Type KeyGen -Module ${{ inputs.modules-to-cache }} -ShellToUse ${{ inputs.shell-to-use }}
          $modulepath = ${{ github.action_path }}/main.ps1 -Type ModulePath
          Write-Output "::set-output name=keygen::$keygen"
          Write-Output "::set-output name=modulepath::$modulepath"
          [pscustomobject]@{
            ModulePath = $modulepath
            Modules    = "${{ inputs.modules-to-cache }}"
          } | Export-CliXml -Path "$home\cache.xml"
        } else {
          $moduleinfo = Import-CliXml -Path "$home\cache.xml"
          Write-Output "Trusting PSGallery"
          Invoke-Command -ScriptBlock {
            ${{ inputs.shell-to-use }} -command { 
              Set-PSRepository PSGallery -InstallationPolicy Trusted
            }
          }
          
          $modulelist = $moduleinfo.Modules
          Write-Output "Saving modules $modulelist to $($moduleinfo.ModulePath)"
          $modules = $modulelist.Split(",").Trim()

          foreach ($module in $modules) {
            Write-Output "Installing module $module on PowerShell $($PSVersionTable.PSVersion)"
            $item, $version = $module.Split(":")
            if ($version) {
              Save-Module $item -RequiredVersion $version -ErrorAction Stop -Force:$${{ inputs.force }} -AllowPrerelease:$${{ inputs.allow-prerelease }} -Path $moduleinfo.ModulePath
            } else {
              Save-Module $item -ErrorAction Stop -Force:$${{ inputs.force }} -AllowPrerelease:$${{ inputs.allow-prerelease }} -Path $moduleinfo.ModulePath
            }
          }
        }
outputs:
  keygen:
    description: "Unique Key Generator"
    value: ${{ steps.psoutput.outputs.keygen }}
  modulepath:
    description: "Default module path for OS"
    value: ${{ steps.psoutput.outputs.modulepath }}
  modules-to-cache:
    description: "Original request"
    value: ${{ inputs.modules-to-cache }}
